# Web开发

Spring Boot provides auto-configuration for Spring MVC that works well with most applications.

The auto-configuration adds the following features on top of Spring’s defaults:

- Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.
- Support for serving static resources, including support for WebJars (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content))).
- Automatic registration of `Converter`, `GenericConverter`, and `Formatter` beans.
- Support for `HttpMessageConverters` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters)).
- Automatic registration of `MessageCodesResolver` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-message-codes)).
- Static `index.html` support.
- Automatic use of a `ConfigurableWebBindingInitializer` bean (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-web-binding-initializer)).

If you want to keep those Spring Boot MVC customizations and make more [MVC customizations](https://docs.spring.io/spring/docs/5.3.6/reference/html/web.html#mvc) (interceptors, formatters, view controllers, and other features), you can add your own `@Configuration` class of type `WebMvcConfigurer` but **without** `@EnableWebMvc`.

If you want to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter`, or `ExceptionHandlerExceptionResolver`, and still keep the Spring Boot MVC customizations, you can declare a bean of type `WebMvcRegistrations` and use it to provide custom instances of those components.

If you want to take complete control of Spring MVC, you can add your own `@Configuration` annotated with `@EnableWebMvc`, or alternatively add your own `@Configuration`-annotated `DelegatingWebMvcConfiguration` as described in the Javadoc of `@EnableWebMvc`.

# 静态资源

## 基础使用

### 匹配机制

静态资源匹配，默认先找controller，找不到再找静态资源文件夹。

这个非常类似springMVC中的请求匹配原理

### 静态资源目录

默认 `/static` (or `/public` or `/resources` or `/META-INF/resources`

修改

````yaml
spring:
  resources:
    static-locations: [classpath:/test/]
````

### 静态资源访问前缀

由于底层匹配机制，如果web中包含大量的静态资源，那么所有请求都得去检查controller，这显然是没有必要的。为静态资源配置专用前缀，就是来解决这个问题，通过拦截器来过滤。

```yaml
spring:
  mvc:
    static-path-pattern: /res/**
```

### 欢迎页支持

- 静态资源路径下  index.html

- - 可以配置静态资源路径
  - 但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问

- controller能处理/index

### 自定义`Favicon`

favicon.ico 放在静态资源目录下即可。

## 静态资源配置源码解析

`@SpringBootApplication`底层回默认加载各种配置类，按需装载。再web应用场景下`WebMvcAutoConfiguration`负责web各种配置。

### 概述

加载WebMvcAutoConfiguration类

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
// 再web场景下，这些类会被加载
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
// 指定加载优先级
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
		ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {}
```

该类包括多个配置子类`WebMvcAutoConfigurationAdapter`,`EnableWebMvcConfiguration`,`ResourceChainCustomizerConfiguration`。这些类注入的时候会使用有参的构造方法，其方法的参数将从context中获取。例如：

````java
public WebMvcAutoConfigurationAdapter(
    WebProperties webProperties, 
    WebMvcProperties mvcProperties,
    ListableBeanFactory beanFactory, 
    ObjectProvider<HttpMessageConverters> messageConvertersProvider,
    ObjectProvider<ResourceHandlerRegistrationCustomizer> resourceHandlerRegistrationCustomizerProvider,
    ObjectProvider<DispatcherServletPath> dispatcherServletPath,
    ObjectProvider<ServletRegistrationBean<?>> servletRegistrations) {
    this.mvcProperties = mvcProperties;
    this.beanFactory = beanFactory;
    this.messageConvertersProvider = messageConvertersProvider;
    this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();
    this.dispatcherServletPath = dispatcherServletPath;
    this.servletRegistrations = servletRegistrations;
    this.mvcProperties.checkConfiguration();
}
````

### 静态资源默认规则源码

我们配置过类似的属性用于设置静态资源的访问。这一部分来看看底层的实现方式。

````yaml
spring:
  mvc:
    static-path-pattern: /res/**
  web:
    resources:
      static-locations: [classpath:/test/]
````

````java

// 添加资源处理器
// @param ResourceHandlerRegistry是用于注册资源的管理器
protected void addResourceHandlers(ResourceHandlerRegistry registry) {
	// 将当前资源注册管理器添加到列表中
	super.addResourceHandlers(registry);
	// 是否映射静态请求，resourceProperties意味着可配置
	if (!this.resourceProperties.isAddMappings()) {
		logger.debug("Default resource handling disabled");
		return;
	}
	ServletContext servletContext = getServletContext();
	// 向registry中添加解析 "/webjars/**"的请求
	addResourceHandler(registry, "/webjars/**", "classpath:/META-INF/resources/webjars/");
	// 向registry中添加解析，我们配置的静态路径以及静态资源相关文件夹
	addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {
		registration.addResourceLocations(this.resourceProperties.getStaticLocations());
		if (servletContext != null) {
			registration.addResourceLocations(new ServletContextResource(servletContext, SERVLET_LOCATION));
		}
	});
}
// 添加资源处理器的方法，最终都会调用如下重载方法
// @param Consumer是一个函数式接口
private void addResourceHandler(ResourceHandlerRegistry registry, String pattern,
		Consumer<ResourceHandlerRegistration> customizer) {
	if (registry.hasMappingForPattern(pattern)) {
		return;
	}
	// 将该pattern添加到注册管理器中，并且返回该pattern的一个注册实例registration
	ResourceHandlerRegistration registration = registry.addResourceHandler(pattern);
	// accept会调用Consummer的匿名lambda函数式接口，向registration添加location信息
	customizer.accept(registration);
	// 设置缓存时间，resourceProperties同样可配置
	registration.setCachePeriod(getSeconds(this.resourceProperties.getCache().getPeriod()));
	// 设置缓存
	registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());
	customizeResourceHandlerRegistration(registration);
}
````

### 欢迎页解析源码

SpringBoot欢迎页机制是：

- 加载静态资源中的index页面
- /index请求用handler进行处理

我们来看底层实现。

````java
// 返回了一个欢迎页面的handlerMapping
@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
		FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {
	// 新建了一个handlerMapping，getWelcomePage()获取欢迎页地址
	WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
			new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),
			this.mvcProperties.getStaticPathPattern());
	welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
	welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());
	return welcomePageHandlerMapping;
}
// 获得欢迎页
private Resource getWelcomePage() {
	// 遍历所有的静态资源地址，检查是否目录下有index.html页面
	for (String location : this.resourceProperties.getStaticLocations()) {
		Resource indexHtml = getIndexHtml(location);
		if (indexHtml != null) {
			return indexHtml;
		}
	}
	ServletContext servletContext = getServletContext();
	if (servletContext != null) {
		return getIndexHtml(new ServletContextResource(servletContext, SERVLET_LOCATION));
	}
	return null;
}

WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,
		ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) {
	// 当其实页面存在的时候，判断此时staticPathPattern的配置是否为默认，拦截/**
	// 是则确认index页面
	if (welcomePage != null && "/**".equals(staticPathPattern)) {
		logger.info("Adding welcome page: " + welcomePage);
		setRootViewName("forward:index.html");
	}
	// 否则尝试交给controller处理
	else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) {
		logger.info("Adding welcome page template: index");
		setRootViewName("index");
	}
}
````

# 请求

## 请求映射

### Rest风格请求的使用

客户端直接发送DELETE或PUT，可以正常映射。

在`SpringMVC`中，由于html页面form表单无法直接发送DELETE和PUT，因而需要手动配置过滤器。在`SpringBoot`中也一样。

在Web配置类`WebMvcAutoConfiguration`中，已有注入该过滤器的代码，不过需要手动启用。根据注解信息，很容易可以看出只需要配置`spring.mvc.hiddenmethod.filter = true`即可，该值默认为false。因为当前不管是客户端或是前后端分离的系统，都能正常发送各种Rest请求。

````java
@Bean
@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
@ConditionalOnProperty(prefix = "spring.mvc.hiddenmethod.filter", name = "enabled", matchIfMissing = false)
public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
    return new OrderedHiddenHttpMethodFilter();
}
````

其原理也非常好理解：

- 表单提交会带上**_method=PUT**
- **请求过来被**HiddenHttpMethodFilter拦截

- - 请求是否正常，并且是POST

- - - 获取到**_method**的值。
    - 兼容以下请求；**PUT**.**DELETE**.**PATCH**
    - **原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。**
    - 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的。

### 请求映射源码解析

该源码几乎就是`SpringMVC`的同款，可以参考`SpringMVC`的相关笔记，这里简单梳理。

#### Rest请求过滤器源码

过滤器原理非常简单

- 使用form隐藏表单提交"_method"字段，指示出提交的Rest请求类型

- 过滤器包装原生request，将方法与_method的字段绑定。

````java
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
		throws ServletException, IOException {

	HttpServletRequest requestToUse = request;

	if ("POST".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {
		// 原生API获取请求参数，注意this.methodParam默认就是"_method"
		String paramValue = request.getParameter(this.methodParam);
		if (StringUtils.hasLength(paramValue)) {
			// 大小写不敏感
			String method = paramValue.toUpperCase(Locale.ENGLISH);
			if (ALLOWED_METHODS.contains(method)) {
				// * 包装原来的request，将原本的GET请求包装为paramValue
				requestToUse = new HttpMethodRequestWrapper(request, method);
			}
		}
	}

	filterChain.doFilter(requestToUse, response);
}
// * 包装类源码非常简单，装饰器设计模式，为原本对象添加其他行为
private static class HttpMethodRequestWrapper extends HttpServletRequestWrapper {
	private final String method;
	public HttpMethodRequestWrapper(HttpServletRequest request, String method) {
		super(request);
		// 修改原来方法
		this.method = method;
	}

	@Override
	public String getMethod() {
		return this.method;
	}
}
````

#### 执行方法，处理映射

和`SpringMVC`几乎一致，这里就不展开了，只简单的总结一下逻辑，请参考笔记 

https://github.com/KDL-in/SpringMVCLearning/blob/master/notes/springMVC_%E6%BA%90%E7%A0%81.md#%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B

`doDispatch`执行逻辑

- 为请求匹配合适的handler，`SpringBoot`默认的handlers变为5个
- 为handler匹配合适的适配器，适配器设计模式
- 执行方法
	- 执行方法前需要一定的初始化工作，包括视图和数据的容器`ModelAndView`
	- 初始化`ModelAndView`，并且这个阶段会先执行`@ModelAttribute`注解的方法，用于先方法前的bean初始化工作
	- 执行方法
		- 获得参数，其中就包括了使用不同的参数解析器解析参数
		- 参数，返回值，方法meta信息，万事俱备，执行方法
		- 返回视图和数据的容器mv
	- 处理mv，跳转和渲染，这其中需要涉及到视图解析的过程

````java
// 处理请求的最终核心方法
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
	HttpServletRequest processedRequest = request;
	HandlerExecutionChain mappedHandler = null;
	boolean multipartRequestParsed = false;

	WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

	try {
		ModelAndView mv = null;
		Exception dispatchException = null;

		try {
			processedRequest = checkMultipart(request);
			multipartRequestParsed = (processedRequest != request);

			// 获得合适的mappedHandler
			mappedHandler = getHandler(processedRequest);
			if (mappedHandler == null) {
				noHandlerFound(processedRequest, response);
				return;
			}

			// 获得合适的Adapter
			HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

			// Process last-modified header, if supported by the handler.
			String method = request.getMethod();
			boolean isGet = "GET".equals(method);
			if (isGet || "HEAD".equals(method)) {
				long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
				if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
					return;
				}
			}

			if (!mappedHandler.applyPreHandle(processedRequest, response)) {
				return;
			}

			// 执行方法
			mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

			if (asyncManager.isConcurrentHandlingStarted()) {
				return;
			}

			applyDefaultViewName(processedRequest, mv);
			mappedHandler.applyPostHandle(processedRequest, response, mv);
		}
		catch (Exception ex) {
			dispatchException = ex;
		}
		catch (Throwable err) {
			// As of 4.3, we're processing Errors thrown from handler methods as well,
			// making them available for @ExceptionHandler methods and other scenarios.
			dispatchException = new NestedServletException("Handler dispatch failed", err);
		}
		// 处理跳转，渲染页面
		processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
	}
	catch (Exception ex) {
		triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
	}
	catch (Throwable err) {
		triggerAfterCompletion(processedRequest, response, mappedHandler,
				new NestedServletException("Handler processing failed", err));
	}
	finally {
		if (asyncManager.isConcurrentHandlingStarted()) {
			// Instead of postHandle and afterCompletion
			if (mappedHandler != null) {
				mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
			}
		}
		else {
			// Clean up any resources used by a multipart request.
			if (multipartRequestParsed) {
				cleanupMultipart(processedRequest);
			}
		}
	}
}
````

## 普通参数与注解

### 注解

`@PathVariable`、`@RequestHeader`、`@ModelAttribute`、`@RequestParam`、`@MatrixVariable`、`@CookieValue`、`@RequestBody`

```java
@RestController
public class ParameterTestController {


    //  car/2/owner/zhangsan
    @GetMapping("/car/{id}/owner/{username}")
    public Map<String,Object> getCar(@PathVariable("id") Integer id,
                                     @PathVariable("username") String name,
                                     @PathVariable Map<String,String> pv,
                                     @RequestHeader("User-Agent") String userAgent,
                                     @RequestHeader Map<String,String> header,
                                     @RequestParam("age") Integer age,
                                     @RequestParam("inters") List<String> inters,
                                     @RequestParam Map<String,String> params,
                                     @CookieValue("_ga") String _ga,
                                     @CookieValue("_ga") Cookie cookie){


        Map<String,Object> map = new HashMap<>();

//        map.put("id",id);
//        map.put("name",name);
//        map.put("pv",pv);
//        map.put("userAgent",userAgent);
//        map.put("headers",header);
        map.put("age",age);
        map.put("inters",inters);
        map.put("params",params);
        map.put("_ga",_ga);
        System.out.println(cookie.getName()+"===>"+cookie.getValue());
        return map;
    }

	// 直接获得参数体
    @PostMapping("/save")
    public Map postMethod(@RequestBody String content){
        Map<String,Object> map = new HashMap<>();
        map.put("content",content);
        return map;
    }


    //1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd
    // sell之后带的数据都是所谓的矩阵变量
    //2、SpringBoot默认是禁用了矩阵变量的功能
    //      手动开启：原理。对于路径的处理。UrlPathHelper进行解析。
    //              removeSemicolonContent（移除分号内容）支持矩阵变量的
    //3、矩阵变量必须有url路径变量才能被解析
    @GetMapping("/cars/{path}")
    public Map carsSell(@MatrixVariable("low") Integer low,
                        @MatrixVariable("brand") List<String> brand,
                        @PathVariable("path") String path){
        Map<String,Object> map = new HashMap<>();

        map.put("low",low);
        map.put("brand",brand);
        map.put("path",path);
        return map;
    }

    // 多路径矩阵变量
    // /boss/1;age=20/2;age=10
    @GetMapping("/boss/{bossId}/{empId}")
    public Map boss(@MatrixVariable(value = "age",pathVar = "bossId") Integer bossAge,
                    @MatrixVariable(value = "age",pathVar = "empId") Integer empAge){
        Map<String,Object> map = new HashMap<>();

        map.put("bossAge",bossAge);
        map.put("empAge",empAge);
        return map;

    }

}
```